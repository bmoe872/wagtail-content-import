{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Wagtail Content Import's Documentation Wagtail Content Import is a module for importing page content into Wagtail from third-party sources. Page content is imported into a StreamField, using a set of customisable mappings. Currently supports: As sources: Google Docs: OneDrive/SharePoint As files: Google Docs documents with: Rich text Tables Images Headings Docx files with: Text with bold and italics Headings","title":"Home"},{"location":"#welcome-to-wagtail-content-imports-documentation","text":"Wagtail Content Import is a module for importing page content into Wagtail from third-party sources. Page content is imported into a StreamField, using a set of customisable mappings. Currently supports:","title":"Welcome to Wagtail Content Import's Documentation"},{"location":"#as-sources","text":"Google Docs: OneDrive/SharePoint","title":"As sources:"},{"location":"#as-files","text":"Google Docs documents with: Rich text Tables Images Headings Docx files with: Text with bold and italics Headings","title":"As files:"},{"location":"basic_usage/","text":"Basic Usage To enable import for a Page model, it should inherit from ContentImportMixin ( wagtail_content_import.models.ContentImportMixin ). By default, content will be imported into into a StreamField called body (see Changing Import Fields for how to change this). You'll then need to create a Mapper, which maps the parsed document into your StreamField blocks. Create a class deriving from wagtail_content_import.mappers.streamfield.StreamFieldMapper : from wagtail_content_import.mappers.converters import ImageConverter , RichTextConverter , TableConverter , TextConverter from wagtail_content_import.mappers.streamfield import StreamFieldMapper class MyMapper ( StreamFieldMapper ): html = RichTextConverter ( my_heading_block ) image = ImageConverter ( my_image_block ) heading = TextConverter ( my_heading_block ) table = TableConverter ( my_table_block ) This would map to an example StreamField defined as: from wagtail.images.blocks import ImageChooserBlock from wagtail.core.blocks import CharBlock , RichTextBlock , StreamBlock from wagtail.contrib.table_block.blocks import TableBlock class BaseStreamBlock ( StreamBlock ): Define the custom blocks that `StreamField` will utilize my_heading_block = CharBlock () my_paragraph_block = RichTextBlock () my_image_block = ImageChooserBlock () my_table_block = TableBlock () Note that the converters require the fields rather than the block classes: 'my_heading_block' , not CharBlock . The above example assumes use of the simple blocks included with Wagtail. For StructBlocks, see Working with StructBlocks . Set mapper_class on your Page model to your new mapper class (or set WAGTAILCONTENTIMPORT_DEFAULT_MAPPER to your mapper use it for all imports by default). You should now see a button near the action menu when creating a new Page of your class in the admin, giving you the option to import a document.","title":"Basic Usage"},{"location":"basic_usage/#basic-usage","text":"To enable import for a Page model, it should inherit from ContentImportMixin ( wagtail_content_import.models.ContentImportMixin ). By default, content will be imported into into a StreamField called body (see Changing Import Fields for how to change this). You'll then need to create a Mapper, which maps the parsed document into your StreamField blocks. Create a class deriving from wagtail_content_import.mappers.streamfield.StreamFieldMapper : from wagtail_content_import.mappers.converters import ImageConverter , RichTextConverter , TableConverter , TextConverter from wagtail_content_import.mappers.streamfield import StreamFieldMapper class MyMapper ( StreamFieldMapper ): html = RichTextConverter ( my_heading_block ) image = ImageConverter ( my_image_block ) heading = TextConverter ( my_heading_block ) table = TableConverter ( my_table_block ) This would map to an example StreamField defined as: from wagtail.images.blocks import ImageChooserBlock from wagtail.core.blocks import CharBlock , RichTextBlock , StreamBlock from wagtail.contrib.table_block.blocks import TableBlock class BaseStreamBlock ( StreamBlock ): Define the custom blocks that `StreamField` will utilize my_heading_block = CharBlock () my_paragraph_block = RichTextBlock () my_image_block = ImageChooserBlock () my_table_block = TableBlock () Note that the converters require the fields rather than the block classes: 'my_heading_block' , not CharBlock . The above example assumes use of the simple blocks included with Wagtail. For StructBlocks, see Working with StructBlocks . Set mapper_class on your Page model to your new mapper class (or set WAGTAILCONTENTIMPORT_DEFAULT_MAPPER to your mapper use it for all imports by default). You should now see a button near the action menu when creating a new Page of your class in the admin, giving you the option to import a document.","title":"Basic Usage"},{"location":"changing_import_fields/","text":"To change how the document's data is imported to the Page model - for example, importing to a StreamField other than body , you'll need to override the create_from_import method. On the ContentImportMixin , this is defined as: from django.utils.text import slugify @classmethod def create_from_import ( cls , parsed_doc , user ): Factory method to create the Page and populate it from a parsed document. title = parsed_doc [ title ] mapper_class = cls . mapper_class mapper = mapper_class () imported_data = mapper . map ( parsed_doc [ elements ], user = user ) return cls ( title = title , slug = slugify ( title ), body = imported_data , owner = user , ) So to import into a different field, simply replace body with the name of your custom field.","title":"Changing Import Fields"},{"location":"custom_converters/","text":"Converters are callable classes which convert {type: type, 'value': value} elements in a parsed document to StreamField blocks. You can write your own custom converters to include functionality not in the core app: for example, working with StructBlocks . Converters should inherit from wagtail_content_import.mappers.converters.BaseConverter , which provides an __init__ method which populates self.block_name , the field name of the StreamField block the converter is creating. Converters should implement a __call__(self, element, **kwargs) method which returns a StreamField-compatible tuple of (self.block_name, content) for an element of the form {type: type, 'value': value} For example, the default TextConverter is implemented simply as: from wagtail_content_import.parsers.converters import BaseConverter class TextConverter ( BaseConverter ): def __call__ ( self , element , ** kwargs ): return ( self . block_name , element [ value ]) To see how to use a custom converter to map into a StructBlock, see working with StructBlocks .","title":"Writing Custom Converters"},{"location":"flow/","text":"The Content Import Flow The Wagtail Content Import app provides: Pickers - which select and import raw document data Parsers - which parse the raw document data into a standard intermediate form Mappers - which convert this intermediate form into a final output (typically a Wagtail StreamField) The typical flow is as follows, for a Page model with ContentImportMixin : The Create view in the Wagtail Admin provides a button, which calls a picker. The picker enables a document to be selected, and makes a POST request to the Create view with the document data. The Wagtail hook for \"before_create_page\" in the picker detects the document, and calls a relevant parser. The parser's parse() method converts the raw document data to a list of {'type': type, 'value': value} elements. The create_page_from_import function is called, which in turn passes the parsed data to the Page model's create_from_import method (inherited from ContentImportMixin ). By default, this creates an instance of the Page's mapper_class , then uses its map() method to call a relevant Converter for each {'type': type, 'value': value} element. This returns a StreamField-compatible list of ('block_name', block_content) tuples. Finally a Page model instance is created (but not saved) with the document's title, and the content inserted into a field called body . The Create view is then rendered with the Page model instance bound to the form.","title":"The Content Import Flow"},{"location":"flow/#the-content-import-flow","text":"The Wagtail Content Import app provides: Pickers - which select and import raw document data Parsers - which parse the raw document data into a standard intermediate form Mappers - which convert this intermediate form into a final output (typically a Wagtail StreamField) The typical flow is as follows, for a Page model with ContentImportMixin : The Create view in the Wagtail Admin provides a button, which calls a picker. The picker enables a document to be selected, and makes a POST request to the Create view with the document data. The Wagtail hook for \"before_create_page\" in the picker detects the document, and calls a relevant parser. The parser's parse() method converts the raw document data to a list of {'type': type, 'value': value} elements. The create_page_from_import function is called, which in turn passes the parsed data to the Page model's create_from_import method (inherited from ContentImportMixin ). By default, this creates an instance of the Page's mapper_class , then uses its map() method to call a relevant Converter for each {'type': type, 'value': value} element. This returns a StreamField-compatible list of ('block_name', block_content) tuples. Finally a Page model instance is created (but not saved) with the document's title, and the content inserted into a field called body . The Create view is then rendered with the Page model instance bound to the form.","title":"The Content Import Flow"},{"location":"getting_started/","text":"Requirements: Django 2.2 Wagtail 2.2 To set up: Run python3 pip install wagtail-content-import . Add 'wagtail_content_import' to INSTALLED_APPS above wagtail.admin Add the urls: include wagtail_import.urls in your urlpatterns in urls.py . This could look like: from django.conf.urls import include , url from wagtail_content_import import urls as wagtail_content_import_urls urlpatterns += [ url ( r , include ( wagtail_content_import_urls )), ] Note that wagtail_content_import.urls must be above wagtail.core.urls in your urlpatterns . Add the relevant pickers: To import from Google Docs, add 'wagtail_content_import.pickers.google' to INSTALLED_APPS above wagtail.admin , then follow the steps given in Google Docs Setup To import from OneDrive/SharePoint, add 'wagtail_content_import.pickers.microsoft' to INSTALLED_APPS above wagtail.admin , then follow the steps given in Microsoft Setup You're now ready to set up how content will be imported to your Page models: see Basic Usage","title":"Basic Setup"},{"location":"getting_started/#requirements","text":"Django 2.2 Wagtail 2.2","title":"Requirements:"},{"location":"getting_started/#to-set-up","text":"Run python3 pip install wagtail-content-import . Add 'wagtail_content_import' to INSTALLED_APPS above wagtail.admin Add the urls: include wagtail_import.urls in your urlpatterns in urls.py . This could look like: from django.conf.urls import include , url from wagtail_content_import import urls as wagtail_content_import_urls urlpatterns += [ url ( r , include ( wagtail_content_import_urls )), ] Note that wagtail_content_import.urls must be above wagtail.core.urls in your urlpatterns . Add the relevant pickers: To import from Google Docs, add 'wagtail_content_import.pickers.google' to INSTALLED_APPS above wagtail.admin , then follow the steps given in Google Docs Setup To import from OneDrive/SharePoint, add 'wagtail_content_import.pickers.microsoft' to INSTALLED_APPS above wagtail.admin , then follow the steps given in Microsoft Setup You're now ready to set up how content will be imported to your Page models: see Basic Usage","title":"To set up:"},{"location":"google_docs_setup/","text":"Setting Up Google Integration Wagtail Google Docs integration relies on Google APIs, which you will first need to enable for your project: Navigate to the Google API Library . Select a project for your Wagtail site, or create a new one now. Find and enable the Google Docs and Google Drive APIs. Find and enable the Google Picker API, and copy its API key to the setting GOOGLE_PICKER_API_KEY . Open the Credentials page in the API Console. Select Create credentials , then OAuth client ID If you haven't already configured the consent screen, you will need to configure this now. Under Scopes for Google APIs , click Add scope . Add ../auth/documents.readonly and ../auth/drive.readonly scopes. Note: adding these sensitive scopes means that you will need to submit your project for verification by Google to avoid user caps and warning pages during use. Add your domain to Authorised domains . For Application type , choose Web application Under Authorised JavaScript origins , add your domain. On the Credentials page, next to your Client ID, click the download item to download a JSON file of your client secret. Copy the text from this file, and use it to set GOOGLE_OAUTH_CLIENT_CONFIG .","title":"Google Docs Setup"},{"location":"google_docs_setup/#setting-up-google-integration","text":"Wagtail Google Docs integration relies on Google APIs, which you will first need to enable for your project: Navigate to the Google API Library . Select a project for your Wagtail site, or create a new one now. Find and enable the Google Docs and Google Drive APIs. Find and enable the Google Picker API, and copy its API key to the setting GOOGLE_PICKER_API_KEY . Open the Credentials page in the API Console. Select Create credentials , then OAuth client ID If you haven't already configured the consent screen, you will need to configure this now. Under Scopes for Google APIs , click Add scope . Add ../auth/documents.readonly and ../auth/drive.readonly scopes. Note: adding these sensitive scopes means that you will need to submit your project for verification by Google to avoid user caps and warning pages during use. Add your domain to Authorised domains . For Application type , choose Web application Under Authorised JavaScript origins , add your domain. On the Credentials page, next to your Client ID, click the download item to download a JSON file of your client secret. Copy the text from this file, and use it to set GOOGLE_OAUTH_CLIENT_CONFIG .","title":"Setting Up Google Integration"},{"location":"microsoft_setup/","text":"Setting Up OneDrive/SharePoint Integration Wagtail OneDrive/SharePoint integration relies on Microsoft APIs, which you will first need to enable for your project: Navigate to the Microsoft Azure app registrations page If you don't have a registration for your project, create a new registration now. Either while creating your registration, or by selecting your project and navigating to Authentication , add a new redirect URI : If you have included wagtail_content_import.urls as follows: url ( r ADDITIONAL_URL_PATH/ , include ( wagtail_content_import_urls )) The redirect URI will be: https://BASE_URL/ADDITIONAL_URL_PATH/microsoft/auth/ (substituting BASE_URL for your site's url, and ADDITIONAL_URL_PATH for the path under which you have included wagtail_content_import.urls ) Navigate to Authentication . Under Implicit grant , add Access tokens and ID tokens , and save. Finally, navigate to Overview , and copy the Application (client) ID into the MICROSOFT_CLIENT_ID setting.","title":"Microsoft Setup"},{"location":"microsoft_setup/#setting-up-onedrivesharepoint-integration","text":"Wagtail OneDrive/SharePoint integration relies on Microsoft APIs, which you will first need to enable for your project: Navigate to the Microsoft Azure app registrations page If you don't have a registration for your project, create a new registration now. Either while creating your registration, or by selecting your project and navigating to Authentication , add a new redirect URI : If you have included wagtail_content_import.urls as follows: url ( r ADDITIONAL_URL_PATH/ , include ( wagtail_content_import_urls )) The redirect URI will be: https://BASE_URL/ADDITIONAL_URL_PATH/microsoft/auth/ (substituting BASE_URL for your site's url, and ADDITIONAL_URL_PATH for the path under which you have included wagtail_content_import.urls ) Navigate to Authentication . Under Implicit grant , add Access tokens and ID tokens , and save. Finally, navigate to Overview , and copy the Application (client) ID into the MICROSOFT_CLIENT_ID setting.","title":"Setting Up OneDrive/SharePoint Integration"},{"location":"settings/","text":"General Settings WAGTAILCONTENTIMPORT_DEFAULT_MAPPER : The Mapper class used by default for Page models with ContentImportMixin, unless mapper_class is overridden. Defaults to StreamFieldMapper. WAGTAILCONTENTIMPORT_GOOGLE_PARSER : The DocumentParser class used for Google Docs. Defaults to GoogleDocumentParser . WAGTAILCONTENTIMPORT_GOOGLE_PARSER : The DocumentParser class used for .docx files. Defaults to DocxParser . Google Picker Settings GOOGLE_OAUTH_CLIENT_CONFIG (Required): The app's Google client secret. (See: Google Docs Setup ) GOOGLE_PICKER_API_KEY (Required): The app's Google Picker API key, allowing selection of Google Docs. (See: Google Docs Setup ) Microsoft Picker Settings MICROSOFT_CLIENT_ID (Required): The app's Microsoft Azure client ID. (See: Microsoft Setup )","title":"Settings Reference"},{"location":"settings/#general-settings","text":"","title":"General Settings"},{"location":"settings/#wagtailcontentimport_default_mapper","text":"The Mapper class used by default for Page models with ContentImportMixin, unless mapper_class is overridden. Defaults to StreamFieldMapper.","title":"WAGTAILCONTENTIMPORT_DEFAULT_MAPPER:"},{"location":"settings/#wagtailcontentimport_google_parser","text":"The DocumentParser class used for Google Docs. Defaults to GoogleDocumentParser .","title":"WAGTAILCONTENTIMPORT_GOOGLE_PARSER:"},{"location":"settings/#wagtailcontentimport_google_parser_1","text":"The DocumentParser class used for .docx files. Defaults to DocxParser .","title":"WAGTAILCONTENTIMPORT_GOOGLE_PARSER:"},{"location":"settings/#google-picker-settings","text":"","title":"Google Picker Settings"},{"location":"settings/#google_oauth_client_config-required","text":"The app's Google client secret. (See: Google Docs Setup )","title":"GOOGLE_OAUTH_CLIENT_CONFIG (Required):"},{"location":"settings/#google_picker_api_key-required","text":"The app's Google Picker API key, allowing selection of Google Docs. (See: Google Docs Setup )","title":"GOOGLE_PICKER_API_KEY (Required):"},{"location":"settings/#microsoft-picker-settings","text":"","title":"Microsoft Picker Settings"},{"location":"settings/#microsoft_client_id-required","text":"The app's Microsoft Azure client ID. (See: Microsoft Setup )","title":"MICROSOFT_CLIENT_ID (Required):"},{"location":"structblocks/","text":"To convert elements in the parsed document to a StructBlock, you'll need to write a custom converter (see Writing Custom Converters .) For a StructBlock, the converter output of a (self.block_name, content) tuple should provide content as a dict. For example, for a StructBlock: from wagtail.core.blocks import CharBlock , ChoiceBlock , StructBlock class HeadingBlock ( StructBlock ): Custom `StructBlock` that allows the user to select h2 - h4 sizes for headers heading_text = CharBlock ( classname = title , required = True ) size = ChoiceBlock ( choices = [ ( , Select a header size ), ( h2 , H2 ), ( h3 , H3 ), ( h4 , H4 ) ], blank = True , required = False ) class Meta : icon = title template = blocks/heading_block.html content should be: { heading_text : heading_text , size : size , } To do this, we could write a converter: from wagtail_content_import.mappers.converters import BaseConverter class HeadingBlockConverter ( BaseConverter ): def __call__ ( self , element , ** kwargs ): return ( self . block_name , { heading_text : element [ value ], size : h2 }) #A More Complex Example: A Custom ImageBlock For a custom ImageBlock: from django.utils.safestring import mark_safe from wagtail.core.blocks import BooleanBlock , StructBlock from wagtail.images.blocks import ImageChooserBlock class ImageBlock ( StructBlock ): show_full_image = BooleanBlock ( required = False ) image = ImageChooserBlock () class Meta : icon = image / picture admin_text = mark_safe ( b Image Block /b ) label = Image Block template = pages/blocks/image_block.html In a StreamField: from wagtail.core.blocks import StreamBlock class BaseBodyStreamBlock ( StreamBlock ): image_block = ImageBlock () We can write a custom converter which borrows some of the functionality of ImageConverter : from wagtail_content_import.mappers.converters import BaseConverter , ImageConverter class ImageBlockConverter ( BaseConverter ): def __call__ ( self , element , user , * args , ** kwargs ): image_url = element [ value ] image_name , image_content = ImageConverter . fetch_image ( image_url ) image = ImageConverter . import_as_image_model ( image_name , image_content , owner = user ) return ( self . block_name , { show_full_image : None , image : image })","title":"Working With StructBlocks"},{"location":"structblocks/#a-more-complex-example-a-custom-imageblock","text":"For a custom ImageBlock: from django.utils.safestring import mark_safe from wagtail.core.blocks import BooleanBlock , StructBlock from wagtail.images.blocks import ImageChooserBlock class ImageBlock ( StructBlock ): show_full_image = BooleanBlock ( required = False ) image = ImageChooserBlock () class Meta : icon = image / picture admin_text = mark_safe ( b Image Block /b ) label = Image Block template = pages/blocks/image_block.html In a StreamField: from wagtail.core.blocks import StreamBlock class BaseBodyStreamBlock ( StreamBlock ): image_block = ImageBlock () We can write a custom converter which borrows some of the functionality of ImageConverter : from wagtail_content_import.mappers.converters import BaseConverter , ImageConverter class ImageBlockConverter ( BaseConverter ): def __call__ ( self , element , user , * args , ** kwargs ): image_url = element [ value ] image_name , image_content = ImageConverter . fetch_image ( image_url ) image = ImageConverter . import_as_image_model ( image_name , image_content , owner = user ) return ( self . block_name , { show_full_image : None , image : image })","title":"#A More Complex Example: A Custom ImageBlock"},{"location":"submitting_backend/","text":"Thanks for being interested in contributing! All contributions should be submitted as pull requests to the Wagtail Content Import repository . Submitting a New Picker If you're planning on submitting a new picker - apps which enable choosing and importing a file from a remote source - you'll need to follow this blueprint: Overview and File Structure Inside wagtail_content_import.pickers , your app should have the following structure: my_picker static wagtail_content_import MY_PICKER.js templates wagtail_content_import MY_PICKER_js_init.html __init__.py apps.py utils.py wagtail_hooks.py Where MY_PICKER should be replaced with the name of your picker. MY_PICKER.js provides the JavaScript class for your picker, which will select a file and make a POST request to the page with relevant data using a hidden form MY_PICKER_js_init.html creates an instance of that class on the Create page, using a template filled in with the relevant settings, and sets up a listener to call that class's .show() method on clicking the relevant import button. __init__.py and apps.py set your app's name and label. utils.py adds your Python picker class, eg GooglePicker wagtail_hooks.py registers your picker using a Wagtail hook, and adds a before_create_page hook to actually take the POST-ed document data and import it, using a parser. The following examples will follow a picker which needs a variable AUTH_PARAMETERS available in the JavaScript in order to import content. MY_PICKER.js This adds the JavaScript class for your picker, and adds it to the window. It should implement a method to show the picker, and upon choosing, make a POST request to the page using a hidden form with relevant data that allows Wagtail to import the document: for the Google picker, this is a JSON containing the document; for the Microsoft picker, this is a temporary url allowing the file to be downloaded. Eg: ( function () { class MyPicker { constructor ( AUTH_PARAMETERS , createPageUrl , csrfToken ) { this . AUTH_PARAMETERS = AUTH_PARAMETERS ; this . createPageUrl = createPageUrl ; this . csrfToken = csrfToken ; } post_data ( response ) { // POST relevant data to the page // Use a hidden form so the browser reloads with the result of this request let form = document . createElement ( form ); form . action = this . createPageUrl ; form . method = POST ; form . style . visibility = hidden ; document . body . appendChild ( form ); let csrfTokenField = document . createElement ( input ); csrfTokenField . type = hidden ; csrfTokenField . name = csrfmiddlewaretoken ; csrfTokenField . value = this . csrfToken ; form . appendChild ( csrfTokenField ); let myDocField = document . createElement ( input ); myDocField . type = hidden ; myDocField . name = my-doc ; myDocField . value = response . value ; form . appendChild ( myDocField ); form . submit (); } show () { # Open the picker here , and call this . post_data ( response ) on successfully getting a file } } window . MyPicker = MyPicker ; })(); MY_PICKER_js_init.html This should provide a Django template which creates an instance of your JS picker class, populated with the relevant variables, which can be filled in by the Django side using your Python picker class. It must also add a listener to the relevant import button, such that when it is clicked, it calls myPicker.show() . Eg: script type = text/javascript document . addEventListener ( DOMContentLoaded , function () { document . querySelectorAll ( [data-content-import-picker= my_picker ] ). forEach ( function ( element ) { let myPicker = new MyPicker ({{ AUTH_PARAMETERS }}, element . dataset . createPageUrl , {{ csrf_token|escapejs }} ); element . addEventListener ( click , function ( e ) { e . preventDefault (); myPicker . show (); }); }); }); / script __init__.py and apps.py init.py : default_app_config = wagtail_content_import.pickers.my_picker.apps.WagtailContentImportMyPickerAppConfig apps.py : from django.apps import AppConfig class WagtailContentImportMyPickerAppConfig ( AppConfig ): name = wagtail_content_import.pickers.my_picker label = wagtail_content_import_my_picker verbose_name = Wagtail Content Import - My Picker utils.py Here, you'll need to create the Python class for your new picker, which will provide the names and context needed by the js_init template. from django.template.loader import render_to_string from django.utils.safestring import mark_safe from wagtail_content_import.pickers import Picker class MyPicker ( Picker ): name = my_picker verbose_name = My Picker def __init__ ( self , AUTH_PARAMETERS ): self . AUTH_PARAMETERS = AUTH_PARAMETERS def get_context ( self ): return { picker : self , AUTH_PARAMETERS : self . AUTH_PARAMETERS , } js_template = wagtail_content_import/MY_PICKER_js_init.html def render_js_init ( self , request ): return mark_safe ( render_to_string ( self . js_template , self . get_context (), request = request )) class Media : css = {} js = [ # ANY EXTRA JS YOU NEED HERE wagtail_content_import/MY_PICKER.js , ] wagtail_hooks.py Finally, here you'll need to register your picker, and add a before create page hook to actually import posted content. Eg: from django.conf import settings from wagtail.core import hooks from .utils import MyPicker from ...utils import create_page_from_import @hooks.register ( before_create_page ) def create_from_my_doc ( request , parent_page , page_class ): if my-doc in request . POST : parsed_doc = # PARSE THE DOCUMENT HERE return create_page_from_import ( request , parent_page , page_class , parsed_doc ) @hooks.register ( register_content_import_picker ) def register_content_import_picker (): return MyPicker ( settings . AUTH_PARAMETERS , )","title":"Submitting a New Backend"},{"location":"submitting_backend/#submitting-a-new-picker","text":"If you're planning on submitting a new picker - apps which enable choosing and importing a file from a remote source - you'll need to follow this blueprint:","title":"Submitting a New Picker"},{"location":"submitting_backend/#overview-and-file-structure","text":"Inside wagtail_content_import.pickers , your app should have the following structure: my_picker static wagtail_content_import MY_PICKER.js templates wagtail_content_import MY_PICKER_js_init.html __init__.py apps.py utils.py wagtail_hooks.py Where MY_PICKER should be replaced with the name of your picker. MY_PICKER.js provides the JavaScript class for your picker, which will select a file and make a POST request to the page with relevant data using a hidden form MY_PICKER_js_init.html creates an instance of that class on the Create page, using a template filled in with the relevant settings, and sets up a listener to call that class's .show() method on clicking the relevant import button. __init__.py and apps.py set your app's name and label. utils.py adds your Python picker class, eg GooglePicker wagtail_hooks.py registers your picker using a Wagtail hook, and adds a before_create_page hook to actually take the POST-ed document data and import it, using a parser. The following examples will follow a picker which needs a variable AUTH_PARAMETERS available in the JavaScript in order to import content.","title":"Overview and File Structure"},{"location":"submitting_backend/#my_pickerjs","text":"This adds the JavaScript class for your picker, and adds it to the window. It should implement a method to show the picker, and upon choosing, make a POST request to the page using a hidden form with relevant data that allows Wagtail to import the document: for the Google picker, this is a JSON containing the document; for the Microsoft picker, this is a temporary url allowing the file to be downloaded. Eg: ( function () { class MyPicker { constructor ( AUTH_PARAMETERS , createPageUrl , csrfToken ) { this . AUTH_PARAMETERS = AUTH_PARAMETERS ; this . createPageUrl = createPageUrl ; this . csrfToken = csrfToken ; } post_data ( response ) { // POST relevant data to the page // Use a hidden form so the browser reloads with the result of this request let form = document . createElement ( form ); form . action = this . createPageUrl ; form . method = POST ; form . style . visibility = hidden ; document . body . appendChild ( form ); let csrfTokenField = document . createElement ( input ); csrfTokenField . type = hidden ; csrfTokenField . name = csrfmiddlewaretoken ; csrfTokenField . value = this . csrfToken ; form . appendChild ( csrfTokenField ); let myDocField = document . createElement ( input ); myDocField . type = hidden ; myDocField . name = my-doc ; myDocField . value = response . value ; form . appendChild ( myDocField ); form . submit (); } show () { # Open the picker here , and call this . post_data ( response ) on successfully getting a file } } window . MyPicker = MyPicker ; })();","title":"MY_PICKER.js"},{"location":"submitting_backend/#my_picker_js_inithtml","text":"This should provide a Django template which creates an instance of your JS picker class, populated with the relevant variables, which can be filled in by the Django side using your Python picker class. It must also add a listener to the relevant import button, such that when it is clicked, it calls myPicker.show() . Eg: script type = text/javascript document . addEventListener ( DOMContentLoaded , function () { document . querySelectorAll ( [data-content-import-picker= my_picker ] ). forEach ( function ( element ) { let myPicker = new MyPicker ({{ AUTH_PARAMETERS }}, element . dataset . createPageUrl , {{ csrf_token|escapejs }} ); element . addEventListener ( click , function ( e ) { e . preventDefault (); myPicker . show (); }); }); }); / script","title":"MY_PICKER_js_init.html"},{"location":"submitting_backend/#__init__py-and-appspy","text":"init.py : default_app_config = wagtail_content_import.pickers.my_picker.apps.WagtailContentImportMyPickerAppConfig apps.py : from django.apps import AppConfig class WagtailContentImportMyPickerAppConfig ( AppConfig ): name = wagtail_content_import.pickers.my_picker label = wagtail_content_import_my_picker verbose_name = Wagtail Content Import - My Picker","title":"__init__.py and apps.py"},{"location":"submitting_backend/#utilspy","text":"Here, you'll need to create the Python class for your new picker, which will provide the names and context needed by the js_init template. from django.template.loader import render_to_string from django.utils.safestring import mark_safe from wagtail_content_import.pickers import Picker class MyPicker ( Picker ): name = my_picker verbose_name = My Picker def __init__ ( self , AUTH_PARAMETERS ): self . AUTH_PARAMETERS = AUTH_PARAMETERS def get_context ( self ): return { picker : self , AUTH_PARAMETERS : self . AUTH_PARAMETERS , } js_template = wagtail_content_import/MY_PICKER_js_init.html def render_js_init ( self , request ): return mark_safe ( render_to_string ( self . js_template , self . get_context (), request = request )) class Media : css = {} js = [ # ANY EXTRA JS YOU NEED HERE wagtail_content_import/MY_PICKER.js , ]","title":"utils.py"},{"location":"submitting_backend/#wagtail_hookspy","text":"Finally, here you'll need to register your picker, and add a before create page hook to actually import posted content. Eg: from django.conf import settings from wagtail.core import hooks from .utils import MyPicker from ...utils import create_page_from_import @hooks.register ( before_create_page ) def create_from_my_doc ( request , parent_page , page_class ): if my-doc in request . POST : parsed_doc = # PARSE THE DOCUMENT HERE return create_page_from_import ( request , parent_page , page_class , parsed_doc ) @hooks.register ( register_content_import_picker ) def register_content_import_picker (): return MyPicker ( settings . AUTH_PARAMETERS , )","title":"wagtail_hooks.py"}]}